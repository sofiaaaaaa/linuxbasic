## 참고문헌
 
1. "DevOps와 SE를 위한 리눅스 커널 이야기", 강진우, 프로그래밍인사이트, 2017.8.16.

<br/><br/>

## 추천의 글 중에서..

  ### 대규모 서비스를 시스템 엔지니어의 시각에서 보여주는 책. 

  실제로 서비스의 문제를 잘 해결하기 위해서는 두 SE의 시각이 필요하다. <br/>
  서비스를 개발하고 운영하는 소프트웨어 엔지니어의 시각과 시스템적인 부분의 운영을 다루는 시스템 엔지니어의 시각이다. <br/>
  문제가 발생하면 코드의 이슈에 집중하는 소프트웨어 엔지니어와 달리 시스템 엔지니어는 시스템의 설정부터 네트워크 환경 등, 코드가 아닌 해당 시스템에 대한 시각으로 문제에 접근한다. <br/>
  실제 서비스를 운영하게 되면 두가지 중 어느 하나의 시각이 덜 중요한 케이스는 없다. <br/>
  
<br/>
## 서문

 최근의 IT시스템에는 클라우드라는 새로운 바람이 불면서 많은 변화가 일어나고 있다. 클라우드를 통해서 누구나 서버를 만들고, 서버에 애플리케이션을 설치하고 서비스할 수 있는 세상이 된 것이다. <br/>

 인프라와 관련된 많은 부분이 소프트웨어화 되어가고 있고 더 편리하게 사용할 수 있도록 변화가 진행 중이다. 그래서 상대적으로 인프라에 대한 관심이 적어지는 것도 현실이다. <br/>

 하지만 역설적으로 누구나 인프라를 구축할 수 있기 때문에 인프라에 더 많은 관심을 가져야한다고 생각한다. 내가 만들고 운영하는 서버이기 때문에 누구도 관심을 가져주지 않고, 누구도 문제를 해결해주지 않기 때문이다. <br/>

 특히 애플리케이션이 구동되는 서버와 관련된 지식이 꼭 필요하다. 애플리케이션이 어떻게 동작하는지, 발생할 수 있는 문제는 없는지, 그리고 문제가 발생하고 있다면, 즉 서비스가 원활하지 않은 이슈가 있다면 그 원인은 무엇인지 확인하고 조치할 수 이어야한다. <br/>

 또한 적절한 성능 테스트와 성능 튜닝을 통해서 서비스를 운영하는데 필요한 서버 대수를 정확하게 산정하고 운영할 수 있어야한다. 그리고 이와 관련된 일련의 작업을 시스템 엔지니어링이라고 한다. <br/>

 시스템 엔지니어링은 서버에서 발생할 수 있는 다양한 이슈들을 확인하고 해결하는 작업이다. 리뉵스 커널 역시 소프트웨어이며, 누군가 로직을 코드로 만들어놓은 거대한 소프트웨어일 뿐이다. <br/>

 커널은 하드웨어를 관리하고 애플리케이션에 하드웨어 작업을 할당하며, 프로세스끼리 영향을 주지 않도록 하기 위해 다양한 방법으로 권한을 관리한다. <br/>

 그래서 커널이 어떤 원리를 가지고 어떻게 동작하는지를 이해하고 모니터링하는 것은 매우 중요한 일이다. 그래야 내가 운영하고 있는 애플리케이션이 적당한 자원을 할당받아서 제대로 된 일을 하고 있는지를 알 수 있고 또 그렇게 동작하도록 지시할 수 있기 때문이다. <br/>

 특히나 요즘과 같이 클라우드 기반으로 서버들이 동작하는 경우야말로, 서버가 낼 수 있는 최대의 성능을 끌어낼 수 있어야 한다. 그리고 이런 작업은 커널에 대한 이해가 바탕이 되어야한다. <br/>

 사실 커널의 동작 원리를 완벽하게 이해한다는 것은 거의 불가능에 가까운 일이다. 커널의 소스 코드는 이미 너무나도 거대하기 때문이다. <br/>

 또한 시간이 지나면서 기능들이 개선되고 변경되기 때문에 완벽하게 이해한다는 것은 더더욱 불가능한 일이 되어가고 있다. 하지만 변하지 않는 근간이 되는 기능들이 있다. 예를 들어 프로세스를 생성하거나 프로세스에 메모리를 할당하거나 네트워크 통신을 위해 TCP를 이용하는 등의 기능들 말이다. <br/>

 기능이 개선되어 가기는 하지만 그 그간간이 변하지 않는 기능들에 대한 이해를 바탕으로 시스템의 문제를 파악하거나, 발생할 수 있는 문제점들을 발견하는 것이 시스템 엔지니어링의 기본이다. <br/>

 어찌보면 이 책은 시스템 엔지니어링을 시작하기 위한 책이라고 볼 수 있다. 위에서 말한 것처럼 기본적인 커널의 이해를 바탕으로 서버에서 발생하고 있는 여러가지 사건들(프로세스끼리 경합을 벌인다거나 비정상적으로 메모리의 사용률이 높아지거나 하는 등)을 해결하기 위한 방법을 살펴보게 될 것이다. 그리고 그런 일이 왜 발생하는지에 대해서도 살펴보게 될 것이다. 이 책의 내용을 발판 삼아서 더 심도있는 시스템 엔지니어링을 하는데 도움이 되기를 바란다. <br/>
<br/>

## 이책의 대상 독자  

이 책은 리눅스 환경에서 애플리케이션을 운영하고 있는 서버 개발자, 개발과 운영을 함께 하고 있는 데브옵스(DevOps), 그리고 리눅스 시스템의 전반적인 운영을 담당하고 있는 시스템 엔지니어들을 대상으로 한다. 

<br/><br/>

## 이 책의 구성

* 1장 : 기본적인 시스템의 구성 정보를 확인하는 방법에 대해서 다룬다. <br/>
  시스템 문제를 파악할 때 가장 기본이 되는 것은 시스템이 어떻게 구성되어 있느냐를 파악하는 것이다. CPU는 어떤 것을 사용하는지, 메모리는 어느 정도 용량으로 장착되어 있는지 등등 시스템의 정보를 알아야 시스템 분석을 할 수 있다. <br/>
<br/>
* 2장 : top명령을 이용한 프로세스의 정보를 확인해본다.  <br/>
top명령으로 ps명령처럼 프로세스의 cpu사용률 정보 및 메모리 할당 정보를 볼 수 있다. <br/> 이 과정에서 프로세스의 상태는 어떤 것들이 있으며, 커널이 어떻게 프로세스에게 메모리를 할당하는지, 그리고 그 정보를 어떻게 확인할 수 있으며 어떤 문제가 숨어있을 수 있는지에 대해 이야기해 볼 것이다.
<br/><br/>
* 3장 : Load Average를 통해 시스템의 부하를 확인하는 과정을 다룬다. <br/>
Load Average는 시스템의 현재 부하를 확인할 때 가장 중요한 정보 중 하나지만, 시스템 구성에 따라 해석이 다를 수 있다. 과연 Load Average가 의미하는 바는 무엇이며, 이를 통해서 시스템의 부하를 어떻게 해석할 수 있는지 이야기한다. <br/><br/>
* 4장 : free 명령을 통해 메모리를 확인하는 과정을 살펴본다.<br/>
free명령은 현재 시스템의 메모리 상태를 전체적으로 확인할 수 있는 중요한 툴이다. <br/> 이를 통해서 시스템의 메모리를 확인하는 과정과 좀 더 자세한 메모리 정보를 확인할 수 있는 방법에 대해서 이야기해 볼 것이다. <br/><br/>
* 5장 : swap과 메모리 증설에 대해 다룬다. swap영역이란 무엇인지, 그리고 swap을 사용하는 것과 메모리 증설이 어떤 관계가 있는지 이야기한다. <br/><br/>
* 6장 : NUMA 아키텍처와 이로 인해 달라지는 메모리 관리를 다루고 있다.<br/>
NUMA아키텍처는 좀더 빠른 메모리 접근을 위해 만들어진 하드웨어 구조이며, 이 구조가 커널의 메모리 할당에 끼치는 영향을 살펴본다. <br/><br/>
* 7장 : TCP Keepalive를 통해 종단간 연결을 유지하는 방법을 알아본다. <br/>
TCP 에는 Keepalive라는 옵션이 있어서 두 종단간 연결을 유지하는 데에 사용할 수 있다.<br/> 이 TCP Keepalive가 어떤 원리로 동작하고 있는지, 그리고 어떤 효과가 있는지를 설명한다. 
<br/><br/>
* 8장 : TIME_WAIT 소켓과 서비스 영향에 대해 다루고 있다.<br/>
 TIME_WAIT소켓이 어떤 과정에서 생성되는지, 그리고 이 소켓이 서비스에 어떤 영향을 끼칠 수 있는지를 알아본다. <br/><br/>

* 9장 : TCP 재전송에 대한 내용을 다루고 있다. <br/>
TCP는 신뢰성있는 통신이기 때문에 그 과정상 반드시 재전송이 발생할 수 밖에 없다. <br/> 재전송이 어떻게 일어나는지를 살펴보고, 서비스에 끼칠 수 있는 영향에 대해서 이야기할 것이다. <br/><br/>

* 10장 : dirty pages와 dirty pages가 I/O에 끼치는 영향에 대해서 다룬다. <br/>
dirty pages는 블록 디바이스에 대한 쓰기 작업의 속도를 향상시키기 위해 도입한 개념이다. <br/>
이 dirty pages가 정확히 어떤 역하을 하는지, 그리고 값의 변화에 따라 I/O 패턴이 어떻게 변화하는지 살펴볼 것이다. <br/>
<br/>
* 11장 : I/O 스케줄러에 대해서 다룬다. <br/>
I/O가 처리되기 위해 반드시 거쳐야하는 I/O 스케줄러에는 어떤 종류가 있는지, 그리고 각각은 어떤 특징이 있는지 알아본다. 
<br/><br/>

* 12장 : 애플리케이션들을 테스트하고 튜닝하는 과정에 대해 알아본다 <br/>
지금까지의 내용들이 커널과 애플리케이션 간의 관계였다면, 마지막 주제는 애플리케이션을 테스트하는 방법과 기본적인 튜닝 포인트에 대해서 이야기한다. <br/>
<br/>
* 부록 A : 커널을 컴파일하는 방법. 단순히 컴파일하는 것이 아니라 원하는 곳에 printk()함수를 추가하여 커널의 디버깅을 좀더 쉽게 하는 방법을 살펴본다. <br/>

* 부록 B : strace 툴의 사용법을 다룬다. 다양한 옵션들을 좀더 세부적으로 살펴보고, strace의 내용을 분석하는 방법에 대해 얘기할 것이다. <br/>

* 부록 C : tcpdump와 와이어샤크를 이용해서 TCP 덤프를 분석하는 것을 다룬다. tcpdump의 다양한 옵션들을 살펴보고, 생성된 덤프 파일을 잘 분석할 수 있도록 와이어샤크에서 제공하는 옵션을 활용하는 방법을 알아볼 것이다. 
 
